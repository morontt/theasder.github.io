---
layout: post
title: "10 cкрытых фич Python"
date: 2016-02-13 2:00:00
description: "Наименее известные, но полезные фичи в языке программирования Python."
category: python
tags: "python, learning, programming, скрытые фичи Python, неизвестные фичи Python, полезные факты о Python, python tricks, python tips"
published: true
---

<img src="http://theasder.github.io/img/python-09.jpg" class="img-responsive" /><br />

Наименее известные, но **полезные фичи** языка программирования **Python**.

<!-- more -->

## 1.	Последовательные цепочки сравнения.

На случай, если вы думаете, что последовательные операции это что-то вроде:
Сравнить `1 < x`, которое равняется `True`. Затем сравнить `True < 10`, которое также равняется истине, &mdash; то нет, это не совсем так. На самом деле цепочка операций получается из преобразования данных выражений к одному, с меньшим количеством символов и вычисляемое только один раз.


    >>> x = 5
    >>> 1 < x < 10
    True
    >>> 10 < x < 20 
    False
    >>> x < 10 < x * 10 < 100
    True
    >>> 10 > x <= 9
    True
    >>> 5 == x > 4
    True


## 2. Получение дерева разбора регулярных выражений Python для отладки ваших регулярных выражений.

Регулярные выражения &mdash; замечательная функция Python, но их отладка достаточно сложна, поэтому очень легко допустить ошибку.

К счастью, Python может вывести дерево разбора регулярных выражений, передав недокументированный, экспериментальный флаг `re.DEBUG` (на самом деле, 128) в `re.compile`


    >>> re.compile("^\[font(?:=(?P<size>[-+][0-9]{1,2}))?\](.*?)[/font]",
     re.DEBUG)
    at at_beginning
    literal 91
    literal 102
    literal 111
    literal 110
    literal 116
    max_repeat 0 1
      subpattern None
        literal 61
        subpattern 1
          in
            literal 45
            literal 43
          max_repeat 1 2
            in
              range (48, 57)
    literal 93
    subpattern 2
      min_repeat 0 65535
        any None
    in
      literal 47
      literal 102
      literal 111
      literal 110
      literal 116


Когда вы поймёте синтаксис, вы сможете без труда обнаружить свои ошибки. В примере выше явно видно, что я забыл экранировать `[]` в `[/font]`. 

Конечно, вы можете комбинировать его с любыми флагами, например с закомментированным регулярным выражением:


    >>> re.compile("""
     ^              # начало строки
     \[font         # тег font
     (?:=(?P<size>  # опционально размер [font=+size]
     [-+][0-9]{1,2} # указание значения размера шрифта
     ))?
     \]             # end of tag завершение тега
     (.*?)          # text between the tags завершение текста между тегами
     \[/font\]      # end of the tag конец тега
     """, re.DEBUG|re.VERBOSE|re.DOTALL)


## 3. Перечисление.

Оберните итератор перечислением, и он соединит элемент с его индексом. 

Например: 


    >>> a = ['a', 'b', 'c', 'd', 'e']
    >>> for index, item in enumerate(a): 
    ...    print index, item
    
    0 a
    1 b
    2 c
    3 d
    4 e
    >>>


Подробнее:

* [Python tutorial—looping techniques](https://docs.python.org/2/tutorial/datastructures.html#looping-techniques)

* [Python docs—built-in functions—enumerate](https://docs.python.org/2/library/functions.html#enumerate)

* [PEP 279](https://www.python.org/dev/peps/pep-0279/)

## 4. Создание генераторов объектов.

Если вы пишите:


    x = (n for n in foo if bar(n))


то вы можете присвоить x выражение генератора. Это значит, что вы можете сделать: 


    for n in x:


Преимуществом этого является то, что вам не нужно промежуточное хранилище, как в случае с


    x = [n for n in foo if bar(n)]


В некоторых случаях это может привести к значительному ускорению.

Вы можете добавить несколько условных операторов в конце генератора, по сути, копируя вложенные циклы:


    >>> n = ((a,b) for a in range(0,2) for b in range(4,6))
    >>> for i in n:
    ...   print i

    (0, 4)
    (0, 5)
    (1, 4)
    (1, 5)

## 5. `iter()` может принимать вызываемый аргумент

Например:


    def seek_next_line(f):
        for c in iter(lambda: f.read(1),'\n'):
            pass


Функция `iter(callable, until_value)` повторно вызывает `callable` и возвращает его результат, пока не будет возвращено `until_value`.

## 6. Будьте осторожны с изменяемыми аргументами по умолчанию.


    >>> def foo(x = []):
    ...     x.append(1)
    ...     print x
    ... 
    >>> foo()
    [1]
    >>> foo()
    [1, 1]
    >>> foo()
    [1, 1, 1]


Вместо этого, вы должны использовать контрольное значение, обозначающее “незаданное” и заменить изменяемое по умолчанию:


    >>> def foo(x = None):
    ...     if x is None:
    ...         x = []
    ...     x.append(1)
    ...     print x
    >>> foo()
    [1]
    >>> foo()
    [1]


## 7. Отправка значений в генератор функций.

Например, для этой функции:


    def mygen():
        """отправлять 5 до тех пор пока что-то другое не возвращено через функцию send()"""
        a = 5
        while True:
            f = (yield a) # передать а и возможно получить f
            if f is not None: 
                a = f  # присвоить новое значение

Вы можете:


    >>> g = mygen()
    >>> g.next()
    5
    >>> g.next()
    5
    >>> g.send(7)  # мы посылаем это обратно генератору
    7
    >>> g.next() # теперь это будет давать 7, пока мы не передадим что-то другое
    7


## 8. Декораторы

Декораторы позволяют обернуть функцию или метод другой функции, которая может добавить функциональности, изменить  аргументы или результаты, и т.д. Декораторы описываются над определением функции, начиная со знака `@`.

Пример показывает `print_args` декоратор,  который печатает аргументы декорируемой функции, прежде чем вызвать её:


    >>> def print_args(function):
    >>>     def wrapper(*args, **kwargs):
    >>>         print 'Arguments:', args, kwargs
    >>>         return function(*args, **kwargs)
    >>>     return wrapper

    >>> @print_args
    >>> def write(text):
    >>>     print text

    >>> write('foo')
    Arguments: ('foo',) {}
    foo


## 9. Начиная с версии 2.5 есть специальный метод `__missing__`, который используется для несуществующих элементов:


    >>> class MyDict(dict):
    ...    def __missing__(self, key):
    ...        self[key] = rv = []
    ...        return rv
    ... 
    >>> m = MyDict()
    >>> m["foo"].append(1)
    >>> m["foo"].append(2)
    >>> dict(m)
    {'foo': [1, 2]}


Также есть подкласс в `collections`, называется `defaultdict`, который делает почти тоже самое, но вызывает функцию без аргументов для несуществующих элементов:


    >>> from collections import defaultdict
    >>> m = defaultdict(list)
    >>> m["foo"].append(1)
    >>> m["foo"].append(2)
    >>> dict(m)
    {'foo': [1, 2]}


Я рекомендую преобразование таких словарей в обычные, перед передачей их в  функции, которые не рассчитаны на такие подклассы. Много кода использует `d[a_key]` и ловит `KeyErrors`, чтобы проверить существует ли какой-то элемент, который добавил бы новый элемент к коллекции.

## 10. Одновременная смена значений.


    >>> a = 10
    >>> b = 5
    >>> a, b
    (10, 5)

    >>> a, b = b, a
    >>> a, b


Правая сторона присвоения &mdash; это выражение, которое создает новый кортеж. Левая сторона немедленно распаковывает этот кортеж в переменные a и b. 

После присваивания, ссылка на новый кортеж удаляется, чтобы дать возможность сработать сборщику мусора, а значения в переменных a и b оказываются поменяны местами.

Перевод: Софья Лепёхина

[Источник](http://stackoverflow.com/questions/101268/hidden-features-of-python#111176)

**Читайте также:**

[11 часто используемых фрагментов кода на Python](http://theasder.github.io/python/2015/09/16/11-most-frequently-used-python-code-fragments.html)

[Интересные приёмы для Python](http://theasder.github.io/python/2014/02/11/python-tricks.html)

[Знания и навыки, полезные для каждого программиста](http://theasder.github.io/skills/2016/01/08/skills-for-programmers.html)
