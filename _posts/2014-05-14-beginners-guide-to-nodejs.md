---
published: false
---

<img src="http://jorshasaur.us/content/images/2014/Feb/nodejs_1280x1024.png" class="img-responsive" /><br />

Нет недостатка в уроках по Node.js, однако большинство из них покрывают конкретные случаи использования или темы, которые применяются исключительно, когда у вас скачен и запущен Node.js. Автором [оригинала этой статьи](http://blog.codeship.io/2014/05/07/nodejs-beginners-guide.html) было замечено множество комментариев в духе "я скачал/скачала Node и что теперь?". Этот урок отвечает на данный вопрос и объясняет новичку с чего начать.

### Что такое Node.js?
Очень много путаницы у новичков из-за непонимания того, что есть Node.js. Описание на [официальном сайте](http://nodejs.org/) совершенно не помогает.

Важную вещь, которую нужно осознать &mdash это то, что Node не веб-сервер. Сама по себе платформа ничего не делает. Она не работает как Apache. Нет конфигаруционных файлов, в которых она указывает вам на HTML файлы. Если вы хотите, чтобы платформа была HTTP сервером, вам придется написать HTTP сервер (с помощью встроенных библиотек). Node.js &mdash; это просто другой спосов выполнять код на вашем компьютере. Это просто среда выполнения языка JavaScript.

### Устанавливаем Node
Node.js легко установить. Достаточно зайти на [страницу загрузки официального сайта](http://nodejs.org/download/).

### Я установил, и что теперь?
Как только вы установили, у вас появилась новая команда в командной строке "node". Вы можете использовать Node двумя способами. Первый &mdash; без аргументов: данная команда откроет интерактивный режим в shell(или командной строке), где вы можете исполнять код JavaScript.

	$ node
	> console.log('Hello World');
	Hello World
	undefined
    
 <img src="http://blog.codeship.io/wp-content/uploads/2014/05/nodejs-guide-1.jpg" class="img-responsive" /><br />
 
В этом примере я просто набрал "console.log('Hello World');" и нажал на Enter. Node начнет выполнять и мы увидем наше сообщение. Также напишет "undefined", потому что печатает возвращаемое значение и `console.log` не возвращает ничего.
 
Другой способ использования Node.js &mdash; это создания файла Javascript. Итак, создаем файл:

#### hello.js

	console.log('Hello World');

И сохраняем его в директорию, из которой будем запускать этот файл. Чтобы перейти достаточно в командной строке написать `cd полное_название_директории` (ну или можно использовать относительную адресацию, об этом можно почитать [здесь](http://younglinux.info/bash/cd.php).

Итак, запускаем в shell(командной строке):

	$ node hello.js
	Hello World

<img src="http://blog.codeship.io/wp-content/uploads/2014/05/nodejs-guide-2.jpg" class="img-responsive" /> <br />

В данном случае мы переместили сообщение файла console.log и отправили этот файл команде node как аргумент. Node запускает код JavaScript в файле и распечатывает "Hello World".

### Файлы ввода/вывода с node.js
Запуск чистого JavaScript &mdash; это здорово, но не очень полезно. Поэтому в Node.js огромное количество [библиотек](http://nodejs.org/api/) (модулей) для того, чтобы делать реальные вещи. В данном примере мы откроем файл с записями и буду его обрабатывать.

#### example_log.txt

	2013-08-09T13:50:33.166Z A 2
	2013-08-09T13:51:33.166Z B 1
	2013-08-09T13:52:33.166Z C 6
	2013-08-09T13:53:33.166Z B 8
	2013-08-09T13:54:33.166Z B 5

Что означает этот файл, не так важно, но просто каждая запись содержит дату, букву и значение. Мы хотим соотнести каждую букву с соответствующим значением.

Нам нужно считать содержание файла.

#### my_parser.js

	// Загружаем модуль файловой системы
	var fs = require('fs');

	// Считываем содержание файла в память
	fs.readFile('example_log.txt', function (err, logData) {
 
		// Если возникла ошибка, мы кидаем исключение
		// и программа заканчивается
		if (err) throw err;
 
		// logData это Буфер, переводим в строку
  		var text = logData.toString();
	});
  
К счастью, Node.js сильно облегчает обработку содержания файла с помощью встроенного модуля [filesystem](http://nodejs.org/api/fs.html) (fs). Модуль fs имеет функцию readFile, которая берет путь к файлу и обратный вызов. Обратный вызов будет исполнен, когда файл будет полностью прочтен. Данные файла попадают в форме типа [Buffer](http://nodejs.org/api/buffer.html), что есть набор битов. Мы можем конвертировать в строку с помощью функции [toString()](http://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end)

Теперь добавим парсировщик (он написан на чистом JavaScript).

#### my_parser.js

    // загружаем модуль filesystem(fs)
    var fs = require('fs');
     
    // считываем содержание файла в память
    fs.readFile('example_log.txt', function (err, logData) {
     
	    // Если возникла ошибка, мы кидаем исключение
		// и программа заканчивается
        if (err) throw err;
     
        // logData имеет тип Buffer, конвертируем в строку
        var text = logData.toString();
     
    var results = {};
     
    // Разбиваем текст на массив из строчек
    var lines = text.split('\n');
     
    lines.forEach(function(line) {
        var parts = line.split(' ');
        var letter = parts[1];
        var count = parseInt(parts[2]);
     
    if(!results[letter]) {
          results[letter] = 0;
    }
     
    results[letter] += parseInt(count);
    });
     
    console.log(results);
    // { A: 2, B: 14, C: 6 }
    });
    
Когда файл будет аргументом команды node, результат распечатается и будет осуществлен выход.

	$ node my_parser.js
	{ A: 2, B: 14, C: 6 }
    
<img src="http://blog.codeship.io/wp-content/uploads/2014/05/nodejs-guide-3.jpg" class="img-responsive"><br/>

### Асинхронные вызовы в node.js
Как вы заметили в прошлом примере, для Node.js характерно использование асинхронных вызовов. По существу вы пишите, что нужно делать, и, когда это будет сделано, будет вызван обратный вызов, потому что node.js однопоточен. Пока вы ждете запуска обратного вызова, Node.js может уйти и делать другие вещи, вместо блокировки до тех пор, пока запрос не завершен.

Это особенно важно в веб-серверах. Довольно характерно для современных веб-приложений иметь доступ к базам данных. Пока вы ждете того, что база данных возвратит результаты, Node может обрабатывать больше запросов. Это позволяет справляться с тысячами параллельных запросов с маленькими накладными расходами по сравнению с созданием отдельного потока для каждого соединения.

### Создание веб-сервера с помощью node.js
Как было уже сказано, в Node ничего не может делать сам по себе. Один из встроенных модулей позволяет легко создать простой [HTTP сервер](http://nodejs.org/api/http.html#http_http_createserver_requestlistener), пример его использования приведен [на главной странице официального сайта](http://nodejs.org/).

#### my_web_server.js
    
    var http = require('http');
     
    http.createServer(function (req, res) {
      res.writeHead(200, {'Content-Type': 'text/plain'});
      res.end('Hello World\n');
    }).listen(8080);
     
    console.log('Server running on port 8080.');

Ещё раз, это базовый веб-сервер, не сервер с полным функционалом. Он не может обслуживать картинки или HTML файлы. На самом деле, какой бы вы не отправили запрос, он возвратит "Hello World". Однако, вы можете запустить этот скрипт и перейти по ссылке [http://localhost:8080](http://localhost:8080) в своем браузере и увидеть этот текст.

	$ node my_web_server.js

Вы могли уже заметить что-то другое. Ваше приложение на node.js больше никогда не выходит. Всё потому, что вы создали веб-сервер и ваше приложение на node.js будет запущено и отвечать на запросы до тех пор, пока вы сами его не остановите.

Если вы хотите сделать веб-сервер с полным функционалом, тогда вам придется проделать работу. Вам придется проверить все запросы, считать подходящие файлы и отправить вывод обратно. Однако, хорошие новости. Люди уже проделали эту тяжелую работу за вас.

### Модуль Express для node.js

[Express](http://expressjs.com/) &mdash это фреймворк, который облегчить создание большинства обычных сайтов. Первым делом вам придется установать его. Вместе с командой node у вас есть доступ к команде "npm". Этот инструмент дает доступ ко огромному количеству модулей, созданных сообществом, в том числе и Express.

    $ cd /my/app/location
    $ npm install express
    
Когда вы установить модуль, он будет положен в папку node_modules в директории вашего приложения. Вы можете теперь его использовать функционал, как будто он встроен. Теперь давайте создадим базовый статический сервер с использованием Express.

#### my_static_file_server.js

    var express = require('express'),
        app = express();
     
    app.use(express.static(__dirname + '/public'));
     
    app.listen(8080);

Запускаем скрипт:
	
    $ node my_static_file_server.js

У вас теперь есть довольно умелый статический файловый сервер. Всё, что вы положили в папку public, может быть запрошено браузером и показано: HTML, картинки, почти что угодно. Так, например, если вы положите картинку под названием “my_image.png” внутрь папки public, вы можете открыть картинку прямо в браузере перейдя по ссылке [http://localhost:8080/my_image.png](http://localhost:8080/my_image.png). Конечно, Express имеет довольно большой функционал, и вы можете изучить его по мере разработки.

### NPM

Мы чуть-чуть затронули npm в предыдцщей секции, но мы хотели бы подчеркнуть как важен этот инструмент при обычной разработке в Node.js. Тысячи модулей доступны для решения почти всех типичных проблем, с которыми вы, вероятно, можете столкнутья. Помните, что стоит проверить npm, прежде чем изобретать велосипед. Это характерно для типичного приложения на node.js иметь множество подключенных модулей.

В предыдущем примере мы вручую установили Express. Если у вас много подключенных библиотек, то не будет хорошей практикой их всех устанавливать. Поэтому npm использует файл package.json. 

#### package.json

    {
      "name" : "MyStaticServer",
      "version" : "0.0.1",
      "dependencies" : {
        "express" : "3.3.x"
      }
    }

Файл package.json содержит обзор вашего приложения. Много доступных полей, но представлен необходимый минимум. Секция "dependency" описывает название и версию модулей, которые вы бы хотели установить. В данном случае мы принимаем любую версию Express.3.3. Вы можете перечислить столько библиоетка, сколько хотите в данной секции.

Теперь вместо того, чтобы устанавливать каждую библиотеку отдельно, мы можем запустить одну команду и установить все нам нужные.

	$ npm install

Когда вы запустите команду, npm будет искать в текущей папке файл package.json. Если найдет, то установит каждую библиотеку из списка.

### Организация кода в node.js

До сих пор мы использовали один файл, но так очень тяжело обслуживать проект. В большинстве приложенией ваш код будет находиться в нескольких файлах. Нет стандартной или принудительной организации того, какие файлы куда идут. Это не Rails. Вы делаете то, что вам хочется. 

Давайте реорганизуем скрипт, обрабатывающий файл с записями. Это будет намного легче тестировать и обслуживать, если мы поместим логику разбора в отдельный файл.

#### parser.js
    
    // Конструктор обработчика
    var Parser = function() {
     
    };
     
    // Обрабатывает заданный текст
    Parser.prototype.parse = function(text) {
     
    var results = {};
     
    // Текст превращает в массив строчек
    var lines = text.split('\n');
     
    lines.forEach(function(line) {
        var parts = line.split(' ');
        var letter = parts[1];
        var count = parseInt(parts[2]);
     
    if(!results[letter]) {
        results[letter] = 0;
    }
     
    results[letter] += parseInt(count);
    });
     
    return results;
    };
     
    // Экспортирует конструктор типа Parser из этого модуля
    module.exports = Parser;
 
То, что я сделал, было созданием нового файла, содержащую логику для обработки записей. Это только стандартный код JavaScript, и существует множество способов внедрить этот код. Я выбрал то, как определить новый объект JavaScript, и это легко модульно тестировать.

Важной строчкой является “module.exports”. Это поясняет Node, что вы экспортируете из этого файла. В данном случае я экспортирую конструктор, поэтому пользователи могут создавать экземпляры моего объекта типа Parser. Вы можете экспортировать, чего хотите.

    // Require my new parser.js file.
    var Parser = require('./parser');
     
    // Load the fs (filesystem) module.
    var fs = require('fs');
     
    // Read the contents of the file into memory.
    fs.readFile('example_log.txt', function (err, logData) {
     
    // If an error occurred, throwing it will
      // display the exception and kill our app.
      if (err) throw err;
     
    // logData is a Buffer, convert to string.
      var text = logData.toString();
     
    // Create an instance of the Parser object.
      var parser = new Parser();
     
    // Call the parse function.
      console.log(parser.parse(text));
      // { A: 2, B: 14, C: 6 }
    });

Файлы включены точно так же, как и модули, кроме того что вы предоставляете путь к файлу вместо имени. Расширение .js подразуемевается, что вы можете оставить привычку писать расширение в конце, если хотите.

Так как я экспортировал конструктор, то это то, что будет возвращено из запроса. Мы можем теперь создавать экземпляры объектов типа Parser и использовать их.

### Вывод

Надеемся, что этот урок был мостом между установкой Node.js и вашем первым приложением. Node.js &mdash; очень мощная и гибкая технология, с помощью которой можно решить широкий круг проблем.

Мы хотим напомнить, что использование Node.js ограничено только вашей фантазией. Библиотеки ядра очень аккуратно разработаны и предоставляют любые инструменты для построения приложения. Скомбинировав всей модули, доступные в npm вы можете удивиться, насколько быстро можно строить очень трудные и очень интересные приложения.